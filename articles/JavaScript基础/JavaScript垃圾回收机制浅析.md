# JavaScript垃圾回收机制浅析

## 前言
无论是在平时的开发还是学习过程中，总会或多或少的看到过“垃圾回收”、“GC”等字眼，总觉得是关于底层的比较有深度的知识点（不明觉厉）。最近看了一些相关的资料，做了一下小结。

就我的习惯而言，思考一个问题基本都是一个套路：
**1. 垃圾回收机制是什么**
**2. 为什么要有这个机制**
**3. 垃圾回收机制是如何工作的**

下面一条一条来看。

## 垃圾回收机制是什么
说到垃圾回收，也有很多地方写GC（Garbage Collecation）。我第一时间的直观感觉这是一个用来回收废弃不用的东西的机制。
那么到底是回收什么东西呢？答案是内存。

这里引用MDN上的说法：
>JavaScript创建变量（对象，字符串等）时分配内存，并且在不再使用它们时“自动”释放。 后一个过程称为垃圾回收。

所以简单来说GC就是：*找出不再使用的变量，然后释放掉其占用的内存。*

## 为什么要有这个机制
说道这个机制的由来，就要说说**内存**这个东西了。内存是程序运行中需要使用的计算机资源，用来存储变量。这个资源是有限的，所以当变量用完以后需要释放掉内存，用来给其他程序使用。

### 内存的生命周期
不管是什么语言，内存的生命周期都是相似的：

1. 分配你所需要的内存
2. 使用分配到的内存（读、写）
3. 不需要时将其释放\归还

前两部分在所有的语言中都很清晰，但是最后一步却有很大的差异。低级语言，比如C语言中是由开发者主动调用free方法释放内存。而高级语言，比如JavaScript则是自动释放，对于开发者是透明的，这就是JavaScript中的垃圾回收机制在起作用了。

## 垃圾回收机制是如何工作的
我们知道垃圾回收机制的工作就是：找出不再使用的变量，然后释放其占用的内存。
那么最主要的问题就应该是在“**找出不再使用的变量**”这一步了。

### 引用
这里要提出一个概念叫做引用：
>在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。
>在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。

知道了引用的概念，那么**找出不再使用的变量**就变为了**找出没有被引用的变量**的问题了。

所以垃圾回收机制的工作原理就是使用“**某种方法**”找出没有被引用的变量，然后释放其占用的内存。

这里提到的“**某种方法**”，指的就是**垃圾回收算法**了，这里介绍两种常见的。

### 引用计数法
这是最常见的GC算法了，这个算法的原理简单来说就是：释放引用数量为0的变量。举个例子：

```
let a = ['1', '2', '3']; // 数组被变量a引用，引用数量为1
let b = a;  // 变量a存储的是数组的引用地址，赋值给b相当于b也引用了数组，引用数量为2
a = null;   // 变量a，不再指向数组，引用数量为1
b = null;   // 变量b，不再指向数组，引用数量为0
```
至此，数组没有被任何变量引用，引用数量为0，等待GC来回收内存。

这个方法很好理解，但是有个很致命的问题，那就是“**循环引用**”的问题。举个例子：

```
function f () {
    let a = {};
    let b = {};
    
    a.p = b;    // a对象的p属性引用了b对象
    b.p = a;    // b对象的p属性引用了a对象
}

f();
```
函数执行完以后本来应该释放掉所用的内存，但是对象a和对象b互相引用，导致各自的引用数量都不为0，GC无法回收内存，导致内存泄漏。

### 标记清除算法
>这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。

这个算法会通过深度遍历根（root）对象，也就是JavaScript的全局对象，来查找所有可以到达的对象，打上标记。然后通过再次遍历，回收所有没有标记的对象。

利用这个算法可以解决循环引用的问题，因为循环引用的变量无法由根对象通过遍历引用到达，所以会被GC回收。

但是也造成了其他的问题，比如多次遍历消耗性能，产生碎片化内存的问题。

>从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。


